<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <input type="file" accept=".xml" id="xmlInput" multiple />
    <label for="xmlReadType">
      <input type="checkbox" id="xmlMerge" />
      Mesclar CT-es
    </label>
    <button onclick="enviarXml()">Enviar</button>
    <pre id="xmlResult"></pre>
  </body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.4/xlsx.full.min.js"></script>
  <script src="./exceljs.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/6.26.0/polyfill.js"></script>

  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/fast-xml-parser/4.3.6/fxparser.min.js"
    integrity="sha512-EYspdactTxZaNYtM83SIGiBKKHK9j+Q8RSh4Ckl912AEDAv7TJe4HfhlwusZHuOiWnVT8Uw3qn5UNf/00apUeQ=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  ></script>
  <script>
    async function enviarXml() {
      const xmlInput = document.getElementById('xmlInput');
      const xmlMerge = document.getElementById('xmlMerge');

      const isMergeCte = xmlMerge.checked;

      console.log(isMergeCte);

      const xmlFiles = xmlInput.files;
      const xmlsContents = await Promise.all(
        Array.from(xmlFiles).map(async (file) => {
          const fileContent = await file.text();
          return fileContent;
        }),
      );

      const parsingOptions = {
        ignoreAttributes: false,
        processEntities: true,
        htmlEntities: true,
        attributeNamePrefix: '',
        numberParseOptions: {
          hex: false,
          skipLike: /\+[0-9]{10}/,
          eNotation: false,
        },
      };

      const ctesInfo = [];
      const rows = xmlsContents.map((content) => {
        const xmlContentParsedAsJSON = new XMLParser(parsingOptions).parse(content);
        const cteInfo = extractCteXmlInfo(xmlContentParsedAsJSON);
        ctesInfo.push(cteInfo);
        return Object.values(cteInfo);
      });

      const allInfo = {
        ctes: ctesInfo.map((cte) => {
          let novoCte = {
            ...cte,
          };
          delete novoCte.valorIcms;
          delete novoCte.valorCarga;

          return novoCte;
        }),
        totalFrete: +ctesInfo
          .reduce((total, cte) => {
            return total + cte.valorFrete;
          }, 0)
          .toFixed(2),
        totalIcms: +ctesInfo
          .reduce((total, cte) => {
            return total + cte.valorIcms;
          }, 0)
          .toFixed(2),
        totalCarga: +ctesInfo
          .reduce((total, cte) => {
            return total + cte.valorCarga;
          }, 0)
          .toFixed(2),
      };

      console.log(allInfo);

      document.getElementById('xmlResult').innerText = JSON.stringify(allInfo, null, 2);

      teste(allInfo, isMergeCte);
    }

    function extractCteXmlInfo({ cteProc }) {
      const infCte = cteProc.CTe.infCte;
      console.log(infCte);

      const [ano, mes, dia] = infCte.ide.dhEmi.split('T')[0].split('-');
      const regexMotorista = /Subcontr:\s\d+-([^-]+)\s-/;
      const matchMotorista = infCte.compl.ObsCont.find((obs) => obs.xCampo === 'Subcontratado:').xTexto.match(
        regexMotorista,
      );
      const motorista = matchMotorista ? matchMotorista[1].trim() : 'NÃO ENCONTRADO';

      // const regexCarga = /(?<=carga:?\s?)\d+/gi;

      const chavesNfe = infCte.infCTeNorm.infDoc.infNFe;
      let cteNotas = [];
      if (Array.isArray(chavesNfe)) {
        cteNotas = chavesNfe.map((nota) => nota.chave.slice(25, 34));
      } else {
        cteNotas.push(chavesNfe.chave.slice(25, 34));
      }
      return {
        motorista,
        dataEmissao: `${dia}/${mes}/${ano}`,
        valorFrete: infCte.vPrest.Comp.vComp,
        produto: infCte.infCTeNorm.infCarga.proPred,
        notas: cteNotas.join(', '),
        origem: infCte.ide.xMunIni,
        destino: infCte.ide.xMunFim,
        numero: infCte.ide.cCT,
        valorIcms: infCte.imp.ICMS.ICMS00.vICMS,
        valorCarga: infCte.infCTeNorm.infCarga.vCarga,
      };
    }

    var global;

    function teste(data, mergeCte) {
      const linha = window.prompt('Digite a linha');
      // Merge cells in the second row

      const ctes = data.ctes.length;
      const dataToSheet = data.ctes.map((cte) => Object.values(cte));
      if (mergeCte) {
        dataToSheet[0].push(data.totalFrete, data.totalIcms);
      }

      const workbook = new ExcelJS.Workbook();
      const worksheet = workbook.addWorksheet('Sheet1');

      worksheet.addRows(dataToSheet);

      // Definindo as mesclagens
      if (mergeCte) {
        const merges = [
          { start: { row: 1, col: 1 }, end: { row: ctes, col: 1 } }, // Merge A1 to A(n)
          { start: { row: 1, col: 2 }, end: { row: ctes, col: 2 } }, // Merge B1 to B(n)
          { start: { row: 1, col: 4 }, end: { row: ctes, col: 4 } }, // Merge D1 to D(n)
          { start: { row: 1, col: 6 }, end: { row: ctes, col: 6 } }, // Merge F1 to F(n)
          ...Array.from({ length: 16 }).map((_, i) => {
            return {
              start: { row: 0, col: i + 8 },
              end: { row: ctes, col: i + 8 },
            };
          }),
        ];
        merges.forEach((merge) =>
          worksheet.mergeCells(merge.start.row, merge.start.col, merge.end.row, merge.end.col),
        );
        // Aplicando as fórmulas
        worksheet.getCell(`K1`).value = { formula: `SUM(I$${linha}-J$${linha})*0.04` };
        worksheet.getCell(`L1`).value = { formula: `SUM(I$${linha}-J$${linha})*0.96` };
        worksheet.getCell(`M1`).value = { formula: `L$${linha}*0.04` };
        worksheet.getCell(`N1`).value = { formula: `L$${linha}*0.005` };
        worksheet.getCell(`P1`).value = { formula: `SUM(L$${linha})-(M$${linha}+N$${linha}+O$${linha})` };
        worksheet.getCell(`U1`).value = { formula: `SUM(T$${linha}*0.00015)*0.0738+(T$${linha}*0.00015)` };
        worksheet.getCell(`X1`).value = { formula: `SUM(W$${linha}*0.04)*(7.38%)+(W$${linha}*0.04%)` };
        worksheet.getCell(`Y1`).value = { formula: `SUM(P$${linha}+X$${linha})-(U$${linha}+W$${linha})` };
      } else {
        data.ctes.forEach((cte, i) => {
          const isFirst = i === 0;
          let linhaDiff = isFirst ? linha : +linha + i;
          worksheet.getCell(`K${i + 1}`).value = { formula: `SUM(I$${linhaDiff}-J$${linhaDiff})*0.04` };
          worksheet.getCell(`L${i + 1}`).value = { formula: `SUM(I$${linhaDiff}-J$${linhaDiff})*0.96` };
          worksheet.getCell(`M${i + 1}`).value = { formula: `L$${linhaDiff}*0.04` };
          worksheet.getCell(`N${i + 1}`).value = { formula: `L$${linhaDiff}*0.005` };
          worksheet.getCell(`P${i + 1}`).value = {
            formula: `SUM(L$${linhaDiff})-(M$${linhaDiff}+N$${linhaDiff}+O$${linhaDiff})`,
          };
          worksheet.getCell(`U${i + 1}`).value = {
            formula: `SUM(T$${linhaDiff}*0.00015)*0.0738+(T$${linhaDiff}*0.00015)`,
          };
          worksheet.getCell(`X${i + 1}`).value = {
            formula: `SUM(W$${linhaDiff}*0.04)*(7.38%)+(W$${linhaDiff}*0.04%)`,
          };
          worksheet.getCell(`Y${i + 1}`).value = {
            formula: `SUM(P$${linhaDiff}+X$${linhaDiff})-(U$${linhaDiff}+W$${linhaDiff})`,
          };
        });
      }

      // Escrevendo o arquivo Excel
      workbook.xlsx
        .writeBuffer()
        .then((buffer) => {
          // Cria um Blob a partir do buffer
          const blob = new Blob([buffer], {
            type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
          });
          // Cria um URL para o Blob
          const url = window.URL.createObjectURL(blob);
          // Cria um link para o URL
          const link = document.createElement('a');
          link.href = url;
          // Define o nome do arquivo
          link.setAttribute('download', 'output.xlsx');
          // Adiciona o link ao documento
          document.body.appendChild(link);
          // Simula um clique no link para iniciar o download
          link.click();
          // Limpa o URL criado
          window.URL.revokeObjectURL(url);
        })
        .catch((error) => {
          console.error('Erro ao gerar a planilha:', error);
        });

      // USANDO OUTRA LIB
      // const merges = [
      //   {
      //     s: { r: 0, c: 0 },
      //     e: { r: ctes, c: 0 },
      //   }, // Merge A1 to A(n)
      //   {
      //     s: { r: 0, c: 1 },
      //     e: { r: ctes, c: 1 },
      //   },
      //   {
      //     s: { r: 0, c: 3 },
      //     e: { r: ctes, c: 3 },
      //   },
      //   {
      //     s: { r: 0, c: 5 },
      //     e: { r: ctes, c: 5 },
      //   },
      //   ...Array.from({ length: 16 }).map((_, i) => {
      //     return {
      //       s: { r: 0, c: i + 8 },
      //       e: { r: ctes, c: i + 8 },
      //     };
      //   }),
      //   // { s: { r: 0, c: 3 }, e: { r: ctes, c: 0 } }, // Merge B(n)
      //   // { s: { r: 0, c: 5 }, e: { r: ctes, c: 0 } }, // Merge B(n)
      // ];

      // const dataToSheet = data.ctes.map((cte) => Object.values(cte));
      // dataToSheet[0].push(data.totalFrete, data.totalIcms, 0);

      // console.log(dataToSheet);

      // // Create a workbook
      // const wb = XLSX.utils.book_new();
      // const ws = XLSX.utils.aoa_to_sheet(dataToSheet);

      // // Apply merges
      // ws['!merges'] = merges;

      // ws['K' + linha] = { t: 'n', f: `=SUM(I${linha}-J${linha})*4%` };
      // ws['L' + linha] = { t: 'n', f: `=SUM(I${linha}-J${linha})*96%` };
      // ws['M' + linha] = { t: 'n', f: `=L${linha}*4%` };
      // ws['N' + linha] = { t: 'n', f: `=(L${linha}*0.5%)` };
      // ws['P' + linha] = { t: 'n', f: `=SUM(L${linha})-(M${linha}+N${linha}+O${linha})` };
      // ws['U' + linha] = { t: 'n', f: `=SUM(T${linha}*0.015%)*(7.38%)+(T${linha}*0.015%)` };
      // ws['Y' + linha] = { t: 'n', f: `=SUM(P${linha}+X${linha})-(U${linha}+W${linha})` };

      // // Add worksheet to the workbook
      // XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');

      // // Generate Excel binary string
      // const excelData = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });

      // // Convert binary string to Blob
      // const blob = new Blob([excelData], { type: 'application/octet-stream' });

      // // Create a download link
      // const url = URL.createObjectURL(blob);
      // const a = document.createElement('a');
      // a.style.display = 'none';
      // a.href = url;
      // a.download = 'excel_file.xlsx';
      // document.body.appendChild(a);

      // // Trigger the download
      // a.click();

      // // Clean up
      // window.URL.revokeObjectURL(url);
      // document.body.removeChild(a);
    }
  </script>
</html>
